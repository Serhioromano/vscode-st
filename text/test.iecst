(* If we disable block, go to to step 0 *)
MOVP(NOT mb_xEnable, 0, iStep);
MOVP(mb_xEnable, 0, iStep);


(* Set defaults *)
MOV(MB_TIMEOUT_COUNT = 0, 2, MB_TIMEOUT_COUNT);
MOV(MB_SUSPEND_RETRY = 0, 80, MB_SUSPEND_RETRY);
MOV(MB_TIMEOUT_TIME = 0, 4, MB_TIMEOUT_TIME);

(* Delay before start communication *)
fbTON1(IN := mb_xEnable, PT := T#3s);
(* Whatchdog timer *)
fbTON2(IN := iStep = 10 OR iStep = 30, PT := INT_TO_TIME(MB_TIMEOUT_TIME * 50));
MOV(fbTON2.Q, mb_arRegs[iCount].iDev, mb_Timeout);
SET(mb_Timeout > 0, xNextChannel);
MOV(mb_Timeout > 0, 20, iStep);
INC(mb_Timeout > 0, mb_arRegs[iCount].iTimeOut);

CASE iStep OF
	0:  (* BOOT DELAY ON START *)
		MOV(fbTON1.Q AND mb_arRegs[0].iRDevNum > 0, 1, iStep);

	1:	(* Set defaults *)
		FOR iIndex := 0 TO 29 DO
			IF mb_arRegs[iIndex].iRDevNum > 0 THEN
				mb_arRegs[iIndex].tStart := TCO_DINT_50;
				MOV(mb_arRegs[iIndex].iRF = 0, H3, mb_arRegs[iIndex].iRF);
				MOV(mb_arRegs[iIndex].iWF = 0, H6, mb_arRegs[iIndex].iWF);
				MOV((mb_arRegs[iIndex].iNum = 0), 1, mb_arRegs[iIndex].iNum);
				mb_arRegs[iIndex].isRegister := (
					mb_arRegs[iIndex].iWF = H6 OR mb_arRegs[iIndex].iWF = H10
					OR mb_arRegs[iIndex].iRF = H3 OR mb_arRegs[iIndex].iRF = H4
				);
			END_IF;
		END_FOR;
		lastIndex := - 1;
		iCount := 0;
		xAlloWrite := FALSE;
		iStep := 20;

	20: (* PREPARE *)
		mb_Timeout := 0;

		IF xAlloWrite
			AND mb_arRegs[iCount].xEnabled = TRUE
			AND (mb_arRegs[iCount].iWR = MB_READ_WRITE OR mb_arRegs[iCount].iWR = MB_WRITE)
			AND (
				(
					mb_arRegs[iCount].iTimeOut >= MB_TIMEOUT_COUNT
					AND DWORD_TO_INT(DTCO_50_DIFF(mb_arRegs[iCount].tStart, TCO_DINT_50)) >= MB_SUSPEND_RETRY
				)
				OR
				(
					mb_arRegs[iCount].iTimeOut < MB_TIMEOUT_COUNT
					AND
					(
						mb_arRegs[iCount].xWriteOnChange = TRUE
						OR
						(
							mb_arRegs[iCount].xWriteOnChange = FALSE
							AND DWORD_TO_INT(DTCO_50_DIFF(mb_arRegs[iCount].tStart, TCO_DINT_50)) >= mb_arRegs[iCount].tCycle
						)
					)
				)
			)
		THEN
			FOR iIndex := 0 TO (mb_arRegs[iCount].iNum - 1) DO
				Z5 := mb_arRegs[iCount].iRDevNum + iIndex;
				Z6 := Z5 + mb_arRegs[iCount].iNum;

				(* If device was changed *)
				IF (
					(mb_arRegs[iCount].isRegister = TRUE AND D0Z5 <> D0Z6)
					OR
					(mb_arRegs[iCount].isRegister = FALSE AND M0Z5 <> M0Z6)
				)
				(* It was NOT a device we updated previouse cycle *)
				AND iIndex > lastIndex THEN
					(* We only support H5, Hf, H6 and H10 function to write. H6 by default *)
					setFunc := mb_arRegs[iCount].iWF;

					IF mb_arRegs[iCount].iWF = H10 OR mb_arRegs[iCount].iWF = HF THEN
						setZ   := mb_arRegs[iCount].iRDevNum;
						setNum := mb_arRegs[iCount].iNum;
						setReg := mb_arRegs[iCount].iReg;
					(* Function H6 *)
					ELSE
						setZ   := mb_arRegs[iCount].iRDevNum + iIndex;
						setNum := 0;
						setReg := mb_arRegs[iCount].iReg + iIndex;
					END_IF;

					lastIndex := iIndex;
					iStep := 10;
				END_IF;
			END_FOR;
		END_IF;

		(* If we do not have any WRITE task lets read *)
		IF iStep = 20
			AND mb_arRegs[iCount].xEnabled = TRUE
			AND (mb_arRegs[iCount].iWR = MB_READ_WRITE OR mb_arRegs[iCount].iWR = MB_READ)
			AND (
				(* In a suspend mode read every MB_SUSPEND_RETRY *)
				(
					mb_arRegs[iCount].tCycle > 0
					AND mb_arRegs[iCount].iTimeOut >= MB_TIMEOUT_COUNT
					AND DWORD_TO_INT(DTCO_50_DIFF(mb_arRegs[iCount].tStart, TCO_DINT_50)) >= MB_SUSPEND_RETRY
				)
				OR
				(* In a normal mode read every tCycle *)
				(
					mb_arRegs[iCount].tCycle > 0
					AND mb_arRegs[iCount].iTimeOut < MB_TIMEOUT_COUNT
					AND DWORD_TO_INT(DTCO_50_DIFF(mb_arRegs[iCount].tStart, TCO_DINT_50)) >= mb_arRegs[iCount].tCycle
				)
				OR
				(* Manual read once *)
				(
					mb_arRegs[iCount].xReadOnce AND NOT mb_arRegs[iCount].xReadOnceM
				)
			)
		THEN
			setFunc := mb_arRegs[iCount].iRF;
			setZ    := mb_arRegs[iCount].iRDevNum;
			setNum  := mb_arRegs[iCount].iNum;
			setReg  := mb_arRegs[iCount].iReg;

			iStep := 10;
		END_IF;
		mb_arRegs[iCount].xReadOnceM := mb_arRegs[iCount].xReadOnce;

		(* Reset first ADPRW call *)
		RST(iStep = 10, xProcess);
		MOV(iStep = 10, mb_arRegs[iCount].iPort, D8397);
		MOV(iStep = 10, mb_arRegs[iCount].iPort, D8126);

		(* If after checking there is nothing to read or write, check another channel *)
		SET(iStep = 20, xNextChannel);
		MOV(iStep = 10 AND NOT mb_arRegs[iCount].isRegister, 30, iStep);

	10: (* Process *)
		Z5 := setZ;
		Z7 := mb_iBuffer;

		(* If we write then move our value to the buffer *)
		BMOV(setFunc = H6, D0Z5, 1, D0Z7);
		BMOV(setFunc = H10, D0Z5, setNum, D0Z7);

        K1X0Z2
		(* Work with registeres *)
		ADPRW(
			xProcess AND mb_Timeout = 0,
			mb_arRegs[iCount].iDev, (* Device adress *)
			setFunc, (* Function to read *)
			setReg, (* Register address *)
			setNum, (* How many registers to read *)
			D0Z7 (* Where to store *)
		);

		IF (M8029) THEN
			(* If it was H6 function we updated 1 register *)
			IF setNum = 0 THEN setNum := 1; END_IF;
			(* If prewiosly was timed out, reset *)
			MOV(mb_arRegs[iCount].iTimeOut > 0, 0, mb_arRegs[iCount].iTimeOut);

			Z6 := Z5 + mb_arRegs[iCount].iNum;

			(* If we write then move our value to the buffer *)
			BMOV((setFunc = H6 OR setFunc = H10), D0Z5, setNum, D0Z6);
			(* If we read *)
			IF setFunc = H3 OR setFunc = H4 THEN
				(* Check if the values had changed while we were deading them
				and if YES then we will not update those. *)

				xHadChanged := FALSE;
				FOR iIndex := 0 TO (setNum - 1) DO
					Z3 := mb_arRegs[iCount].iRDevNum + iIndex ;
					Z4 := mb_arRegs[iCount].iRDevNum + mb_arRegs[iCount].iNum + iIndex;
					SET(mb_arRegs[iCount].iWR <> MB_READ AND D0Z3 <> D0Z4, xHadChanged);
				END_FOR;

				Z5 := setZ;
				Z6 := Z5 + mb_arRegs[iCount].iNum;
				(* Write from buffer to store and then to control value *)
				BMOV(NOT xHadChanged, D0Z7, setNum, D0Z5);
				BMOV(NOT xHadChanged, D0Z5, setNum, D0Z6);
			END_IF;
			(* Save values *)
			RST(TRUE, M8029);
			iStep := 20;

			(* The only condition we do not go to the next channel *)
			IF NOT (mb_arRegs[iCount].iNum > 1 AND setFunc = H6) THEN
				mb_arRegs[iCount].tStart := TCO_DINT_50;
				xNextChannel := TRUE;
			END_IF;
		END_IF;
		(* First ADPRW call is a reset *)
		xProcess := TRUE;
	30:
		Z5 := setZ;
		Z7 := mb_iBuffer;

		MOV(setFunc = H5 AND M0Z5, HFF00, D0Z7);
		MOV(setFunc = H5 AND NOT M0Z5, H0000, D0Z7);

		(* Work with coils *)
		ADPRW(
			xProcess AND mb_Timeout = 0,
			mb_arRegs[iCount].iDev,
			setFunc,
			setReg,
			setNum,
			D0Z7
		);

		IF (M8029) THEN
			(* If it was H6 function we updated 1 register *)
			IF setNum = 0 THEN setNum := 1; END_IF;
			(* If prewiosly was timed out, reset *)
			MOV(mb_arRegs[iCount].iTimeOut > 0, 0, mb_arRegs[iCount].iTimeOut);

			(* If we write then move our value to the buffer *)
			xBit := MBMOV(setFunc = H5 OR setFunc = HF, setZ, setNum, setZ + mb_arRegs[iCount].iNum);

			(* If we read *)
			IF setFunc = H1 OR setFunc = H2 THEN
				(* Check if the values had changed while we were deading them
				and if YES then we will not update those. *)

				xHadChanged := FALSE;
				FOR iIndex := 0 TO (setNum - 1) DO
					Z3 := mb_arRegs[iCount].iRDevNum + iIndex ;
					Z4 := mb_arRegs[iCount].iRDevNum + mb_arRegs[iCount].iNum + iIndex;
					SET(mb_arRegs[iCount].iWR <> MB_READ AND M0Z3 <> M0Z4, xHadChanged);
				END_FOR;

				IF NOT xHadChanged THEN
					FOR iIndex := 0 TO mb_arRegs[iCount].iNum - 1 DO
						Z5 := setZ + iIndex;
						Z6 := Z5 + mb_arRegs[iCount].iNum;

						iRegsInBIts := SEL(iIndex > 16, 0, (iIndex / 16));
						iBit := iIndex - (iRegsInBIts * 16);
						Z4 := mb_iBuffer + iRegsInBIts;

						M0Z5 := ISBON(D0Z4, iBit);
						M0Z6 := ISBON(D0Z4, iBit);
					END_FOR;
				END_IF;
			END_IF;
			(* Save values *)
			RST(TRUE, M8029);
			iStep := 20;

			(* The only condition we do not go to the next channel *)
			IF NOT (mb_arRegs[iCount].iNum > 1 AND setFunc = H5) THEN
				mb_arRegs[iCount].tStart := TCO_DINT_50;
				xNextChannel := TRUE;
			END_IF;
		END_IF;

		(* First ADPRW call is a reset *)
		xProcess := TRUE;

END_CASE;


(* If switch to next channel mpve index *)
IF xNextChannel THEN
	xNextChannel := FALSE;
	IF (iCount = 29) THEN
		iCount := 0;
	ELSE
		IF mb_arRegs[iCount + 1].iRDevNum > 0 THEN
			iCount := iCount + 1;
		ELSE
			iCount := 0;
		END_IF;
	END_IF;
	(* If we change channel, we went though all registers in channel *)
	lastIndex := - 1;
	(* If we are in channel 0 we whent through all channels at least once and can start writing *)
	SET((iCount = 0), xAlloWrite);
END_IF;
